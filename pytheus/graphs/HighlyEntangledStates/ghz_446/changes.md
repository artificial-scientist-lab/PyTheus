Starting from the original graph:
```
original = Graph({ # one must use the Graph class from the PyTheus library
        "(0, 3, 1, 1)": 0.5805251177983758,
        "(0, 2, 1, 1)": 0.6533326774542422,
        "(0, 5, 1, 0)": -0.6748251265948007,
        "(1, 3, 1, 1)": -0.7472685678923824,
        "(1, 2, 1, 1)": -0.8409916346946469,
        "(3, 4, 1, 0)": 0.8591224397438424,
        "(1, 5, 1, 0)": 0.8689003332539588,
        "(2, 4, 1, 0)": 0.9668921097286931,
        "(2, 3, 3, 3)": 0.9756440946097538,
        "(1, 2, 0, 0)": -0.9870193848992934,
        "(0, 2, 2, 2)": 0.9870337649633187,
        "(1, 3, 2, 2)": 0.9883043426479682,
        "(0, 3, 0, 0)": -0.9883200702198167,
        "(4, 5, 0, 0)": 0.9989906799916807,
        "(0, 1, 3, 3)": 0.9999766911035382
    })
```
We rescale all weights with `-1`, which leads to the same state: `original.rescale(-1)`.
We remove some negative signs by flipping the edges connected to 3 of the nodes.
```
original.flipNode(0)
original.flipNode(3)
original.flipNode(5)
```
Finally, we rename the dimensions for the first 4 nodes. Again, it leads to the same GHZ state.
```
for nd in range(4):
    original.switchColors(nd,1,3)
for nd in range(4):
    original.switchColors(nd,0,3)
```
This leads to the plotted graph:
``` 
{                                  # Analytical solution:
(0, 1, 1, 1): 0.9999766911035382,  # 1
(0, 2, 0, 0): 0.6533326774542422,  # 2 ** (-1/2)
(0, 2, 2, 2): 0.9870337649633187,  # 1
(0, 3, 0, 0): -0.5805251177983758, # -2 ** (-1/2)
(0, 3, 3, 3): 0.9883200702198167,  # 1
(0, 5, 0, 0): 0.6748251265948007,  # 2 ** (-1/4)
(1, 2, 0, 0): 0.8409916346946469,  # 2 ** (-1/2)
(1, 2, 3, 3): 0.9870193848992934,  # 1
(1, 3, 0, 0): -0.7472685678923824, # -2 ** (-1/2)
(1, 3, 2, 2): 0.9883043426479682,  # 1
(1, 5, 0, 0): 0.8689003332539588,  # 2 ** (-1/4)
(2, 3, 1, 1): 0.9756440946097538,  # 1
(2, 4, 0, 0): -0.9668921097286931, # -2 ** (-1/4)
(3, 4, 0, 0): 0.8591224397438424,  # 2 ** (-1/4)
(4, 5, 0, 0): 0.9989906799916807   # 1
}
```